/**
 * INSTACLARITY API
 * INSTACLARITY API
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.swagger.client.request;


import com.android.volley.AuthFailureError;
import com.android.volley.NetworkResponse;
import com.android.volley.ParseError;
import com.android.volley.Request;
import com.android.volley.Response;
import com.android.volley.VolleyLog;
import com.android.volley.toolbox.HttpHeaderParser;
import com.google.gson.Gson;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.UnsupportedEncodingException;
import java.lang.reflect.Type;
import java.net.URLEncoder;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public class CustomRequest extends Request<Object> {
    private Object jsonBody;
    private Response.Listener mListener;
    private String contentType;
    private Map<String, String> mHeaders;
    private static final String PROTOCOL_CHARSET = "utf-8";
    private Map<String, String> formBody;
    // private Class mModelClass;
    private Type mResponseContainerType;
    private Gson gson = new Gson();

    public CustomRequest(int method, String url, Map<String, String> headers, String contentType,
                         Object jsonBody, Map<String, String> formBody, Type responseContainerType,
                         Response.Listener listener, Response.ErrorListener errorListener) {
//        Method.DELETE;
        super(method, url, errorListener);
        mListener = listener;
        this.jsonBody = jsonBody;
        this.formBody = formBody;
        this.contentType = contentType;
        mHeaders = headers;
        setShouldCache(false);
        mResponseContainerType = responseContainerType;
    }


    @Override
    public String getBodyContentType() {
        return contentType;
    }

    @Override
    public byte[] getBody() throws AuthFailureError {
        String body = null;
        if (jsonBody == null)       // form data
        {
            if (!(formBody == null || formBody.isEmpty())) {
                StringBuilder formParamBuilder = new StringBuilder();

                // encode the form params
                for (String key : formBody.keySet()) {
                    String value = formBody.get(key);
                    if (value != null && !"".equals(value.trim())) {
                        if (formParamBuilder.length() > 0) {
                            formParamBuilder.append("&");
                        }
                        try {
                            formParamBuilder.append(URLEncoder.encode(key, "utf8")).append("=")
                                    .append(URLEncoder.encode(value, "utf8"));
                        } catch (Exception e) {
                            // move on to next
                        }
                    }
                }
                body = formParamBuilder.toString();
            }
        } else {
            body = gson.toJson(jsonBody);
        }
        try {
            return body == null ? null : body.getBytes(PROTOCOL_CHARSET);
        } catch (UnsupportedEncodingException uee) {
            VolleyLog.wtf("Unsupported Encoding while trying to get the bytes of %s using " +
                    "%s", jsonBody, PROTOCOL_CHARSET);
            return null;
        }
    }


    private JSONObject getMessage(JSONObject jsonObject) throws JSONException {
        if (jsonObject.has("message") && jsonObject.getString("message").startsWith("{")) {
            JSONObject messageObject = jsonObject.getJSONObject("message");
            String key = messageObject.keys().next();
            String message = messageObject.get(key).toString();
            message = message.substring(2, message.length() - 2);
            jsonObject.remove("message");
            jsonObject.put("message", message);
        }
        return jsonObject;
    }

    @Override
    protected Response parseNetworkResponse(NetworkResponse response) {
        try {
            try {

                response.headers.remove("Content-Language");
            } catch (Exception e) {
                e.printStackTrace();
            }
            String responseString = new String(response.data, HttpHeaderParser.parseCharset
                    (response.headers, PROTOCOL_CHARSET));

            if (getUrl().contains("/o/token/")) {
                responseString = "{\"status\":200,\"message\":\"Success\",\"response\":" + responseString + "}";
            }

            JSONObject jsonObject = new JSONObject(responseString);
            jsonObject = getMessage(jsonObject);
            responseString = jsonObject.toString();

            if (mResponseContainerType == null) {
                return Response.success(responseString, HttpHeaderParser.parseCacheHeaders
                        (response));
            } else {
                return Response.success(gson.fromJson(responseString, mResponseContainerType),
                        HttpHeaderParser.parseCacheHeaders(response));
            }

        } catch (UnsupportedEncodingException e) {
            return Response.error(new ParseError(e));
        } catch (Exception e) {
            return Response.error(new ParseError(e));
        }
    }

    @Override
    protected void deliverResponse(Object response) {
        mListener.onResponse(response);
    }

    /* (non-Javadoc)
     * @see com.android.volley.Request#getHeaders()
     */
    @Override
    public Map<String, String> getHeaders() throws AuthFailureError {
        Map<String, String> headers = super.getHeaders();
        if (headers == null || headers.equals(Collections.emptyMap())) {
            headers = new HashMap<>();
        }
        if (mHeaders != null && !mHeaders.equals(Collections.emptyMap())) {
            headers.putAll(mHeaders);
        }
        return headers;
    }
}